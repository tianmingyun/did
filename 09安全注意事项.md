# DID V1.0核心架构、数据模型和表示法-09

#  9. 安全注意事项

本部分是非规范性的。

本节包含各种安全注意事项，建议使用去中心化标识符的人员在将该技术部署到生产环境中之前考虑这些注意事项。 DID 设计为在许多 IETF 标准使用的威胁模型下运行，并记录在[[RFC3552\]](https://www.w3.org/TR/2021/PR-did-core-20210803/#bib-rfc3552)中。 本节详细阐述[[RFC3552\]](https://www.w3.org/TR/2021/PR-did-core-20210803/#bib-rfc3552)中的一些注意事项，以及 DID 架构特有的其他注意事项。

## 9.1 选择 DID 解析器

DID 规范注册表 [[DID-SPEC-REGISTRIES\]](https://www.w3.org/TR/2021/PR-did-core-20210803/#bib-did-spec-registries) 包含 DID 方法名称及其对应的 DID 方法规范的信息列表。 实施者需要牢记，没有中央机构可以强制要求将哪个 DID 方法规范与任何特定的 DID 方法名称一起使用。 如果对特定 DID 解析器是否正确实现 DID 方法存在疑问，则可以使用 DID 规范注册表查找已注册的规范，并就使用哪个 DID 解析器实现做出明智的决定。

## 9.2 证明控制和绑定

将数字世界或物理世界中的实体绑定到 DID、DID 文档或加密材料需要使用本规范所设想的安全协议。 以下部分描述了一些可能的场景以及其中的实体如何证明对 DID 或 DID 文档的控制以用于身份验证或授权。

**证明对 DID 和/或 DID 文档的控制**

在可验证的数据注册表中更新或使用远程系统进行身份验证时，证明对 DID 和/或 DID 文档的控制非常有用。 加密数字签名和可验证的时间戳使与 DID 文档相关的某些安全协议能够以加密方式验证。 出于这些目的，本规范在 第5.3.1 “认证Authentication” 和 第 5.3.4 “能力调用Capability Invocation ”中定义了有用的验证关系。 与验证方法相关的秘密密码材料可用于生成密码数字签名，作为认证或授权安全协议的一部分。

> 注意：签署的 DID 文件
>  某些 DID 方法允许将数字签名和其他证明包含在 DID 文档或第 7.3 节“元数据结构”中。 然而，这些证明本身并不一定证明对 DID 的控制，或保证 DID 文档是 DID 的正确文档。 为了获得正确的 DID 文档并验证对 DID 的控制，有必要执行 DID 方法定义的 DID 解析过程。

**绑定到物理身份**

DID 和 DID 文档本身不包含任何个人数据，强烈建议非公共实体不要在 DID 文档中发布个人数据。

将 DID 与个人或组织的物理身份的绑定以一种可被信任的权威机构（例如政府）可证明的方式表达是很有用的。本规范为这些目的提供了 第 5.3.2 “断言验证”关系。此功能可以实现私密的交互，并且可以被认为在一个或多个司法管辖区具有法律强制执行力；建立此类绑定必须仔细权衡隐私考虑（请参阅第 10 节“隐私考虑”）。

将 DID 绑定到物理世界中的某物（例如个人或组织）的过程（例如，通过使用与该 DID 具有相同主体的可验证凭证[verifiable credentials](https://www.w3.org/TR/2021/PR-did-core-20210803/#dfn-verifiable-credentials)）由本规范设想，并在可验证凭证数据模型中进一步定义[[VC-数据模型\]](https://www.w3.org/TR/2021/PR-did-core-20210803/#bib-vc-data-model)。

## 9.3 认证服务端点

如果 DID 文档发布了旨在对 DID 主体进行身份验证或授权的服务（请参阅第 5.4 节“服务”），则服务端点提供者、主体或请求方有责任遵守该服务端点支持的身份验证协议的要求。

## 9.4 不可否认性

在以下情况下支持 DID 和 DID 文档更新的不可否认性：

- 可验证数据注册表支持可验证时间戳。 有关可在 DID 解析过程中使用的有用时间戳的更多信息，请参阅第 7.1.3 节 “DID 文档元数据”。
- 主体正在监控未经授权的更新，如第 9.5 节 “DID 文档更改通知”中所述。
- 主体有足够的机会根据 DID 方法的授权机制恢复恶意更新。

## 9.5 DID 文档变更通知

缓解对 DID 文档进行未经授权的更改的影响是监视并在发生更改时主动通知 DID 主体。 这类似于通过向存档的电子邮件地址发送密码重置通知，来防止对常规形式用户名/密码帐户丢失。

对于 DID，没有中介注册商或帐户提供商来生成此类通知。 但是，如果注册 DID 的可验证数据注册表直接支持更改通知，则可以向 DID 控制器提供订阅服务。 通知可以直接发送到现有 DID 中列出的相关服务端点。

如果 DID 控制器选择依赖第三方监控服务（除了可验证的数据注册表本身），这将引入另一个攻击向量。

## 9.6 密钥和签名过期

在去中心化标识符架构中，可能没有中心化机构来执行加密材料或加密数字签名过期策略。 因此，请求方通过支持软件（例如 DID 解析器和验证库）来验证加密材料在使用时没有过期。 除了在验证过程中输入内容之外，请求方可能会使用自己的过期策略。 例如，一些请求方可能会接受过去5分钟的认证，而其他能够访问高精度时间源的人可能会要求认证的时间戳在过去500毫秒内。

有一些请求方有合法需求来扩展已经过期的加密材料的使用，例如验证旧的加密数字签名。 在这些情况下，请求方可能会指示他们的验证软件忽略加密密钥材料的过期或确定加密密钥材料在使用时是否过期。

## 9.7 验证方法轮换（Verification Method Rotation）

轮换是一种管理过程，一旦将新的验证方法添加到 DID 文档中，与现有验证方法相关的秘密密码材料就可以被停用或销毁。 展望未来，控制器将使用旧的秘密密码材料生成的任何新证明会被取代，使用新的密码材料生成，并且可以使用新的验证方法进行验证。

轮换是防止验证方法被破坏的一个有用的机制，因为控制器经常轮换验证方法，可以减少单一被破坏的验证方法对攻击者的价值。在轮换后立即执行撤销，对于控制器指定的短期验证的验证方法是有用的，例如那些参与加密信息和认证的方法。

在考虑使用验证方法轮换时，可能需要考虑以下注意事项：

- 验证方法轮换是一种主动安全措施。
- 定期执行验证方法轮换通常被认为是最佳实践。
- 更高的安全环境倾向于采用更频繁的验证方法轮换。
- 验证方法轮换仅表现为对 DID 文档的当前或最新版本的更改。
- 当验证方法已经激活了很长时间，或者用于许多操作时，控制器可能希望执行轮换。
- 对于被迫不断更新或刷新相关凭证的各方来说，验证方法的频繁轮换可能会令人沮丧。
- 那些证明或签名，如果依赖于未出现在最新版本的 DID 文档中的验证方法，则不受轮换的影响。在这些情况下，验证软件可能需要额外的信息，例如预期特定验证方法何时有效以及访问包含历史记录的可验证数据注册表，以确定证明或签名的有效性。此选项可能不适用于所有 DID 方法。
- DID 方法操作部分指定了 DID 方法规范支持的 DID 操作，包括预期用于执行验证方法轮换的更新。
- 控制器在添加新的验证方法时执行轮换，该验证方法旨在在一段时间后替换现有的验证方法。
- 并非所有 DID 方法都支持验证方法轮换。

## 9.8 验证方法撤销（Verification Method Revocation）

撤销是一种管理过程，它使与现有验证方法相关的秘密密码材料能够被停用，从而使其不再是创建新的数字签名证明的有效形式。

撤销是对验证方法妥协做出反应的有用机制。 在轮换后立即执行撤销对于控制器指定用于短期验证的验证方法很有用，例如那些涉及加密消息和身份验证的验证方法。

泄露与验证方法相关的秘密允许攻击者根据控制器在DID文档中表达的验证关系使用它们，例如进行身份验证。 从注册验证方法到撤销验证方法的时间，攻击者对机密的使用可能与合法控制器的使用没有区别。

在考虑使用验证方法撤销时，可能会用到以下注意事项：

- 验证方法撤销是一种反应性安全措施。
- 支持密钥撤销被认为是最佳实践。
- 控制器应立即撤销任何已知被破坏的验证方法。
- 验证方法的撤销只能体现在对最新版本的 DID 文档的更改中； 它不能追溯调整以前的版本。
- 如第 5.2.1 节“验证材料”中所述，（DID文档中）验证方法空缺是唯一撤销形式，适用于所有支持撤销 的DID 方法。
- 如果控制者或受信任代表控制者行事的各方不再能够独家访问验证方法，则预计将立即撤销该验证方法，以降低伪装、盗窃和欺诈等危害的风险。
- 撤销应被理解为控制器表示与撤销后创建的已撤销验证方法相关的证明或签名应被视为无效。 这也可能意味着担心现有的证明或签名可能是由攻击者创建的，但情况不一定如此。 但是，验证者仍然可以自行决定接受或拒绝任何此类证明或签名。
- DID 方法操作部分指定了 DID 方法规范要支持的 DID 操作，包括更新和停用，这可能用于从 DID 文档中删除验证方法。
- 并非所有 DID 方法都支持验证方法撤销。
- 即使 DID 文档中存在验证方法，也可以使用其他信息（例如公钥撤销证书或外部允许或拒绝列表）来确定验证方法是否已被撤销。
- 当验证方法被公开撤销时，任何依赖受损验证方法的软件（例如个人的操作系统、防病毒软件或端点保护软件）的日常运行都可能受到影响。



**撤销语义**

尽管验证者可能会选择不接受来自于撤销验证方法的证明或签名，但要知道是否使用已撤销验证方法进行了验证，比看起来要复杂得多。 一些 DID 方法提供了在某个时间点或 DID 文档的特定版本中回顾 DID 状态的能力。 当这样的特性与确定时间或 DID 版本的可靠方法相结合时，这时一个加密可验证的语句被发出时，那么撤销行为就不会取消（undo）该语句。 这可以作为使用 DID 做出具有约束力的承诺的基础； 例如，签署抵押贷款。

如果满足这些条件，撤销不具有追溯力； 它只会使将来使用该方法无效。

然而，为了使这种语义安全，第二个条件——知道在做出断言时 DID 文档的状态的能力——应该适用。 如果没有这种保证，有人可能会发现一个被撤销的密钥，并使用它来制作具有过去模拟日期的可加密验证语句。

一些 DID 方法只允许检索 DID 的当前状态。 如果这是真的，或者当一个 DID 在加密可验证语句时的状态不能可靠地确定时，那么唯一安全的做法是不允许任何关于时间的 DID 状态的考虑，除了当前时刻。 采用这种方法的 DID 生态系统本质上提供了可加密验证的语句作为临时令牌，可以随时由 DID 控制器失效。

**无信任系统中的撤销**

无信任系统是指所有信任都来自加密可证明断言的系统，更具体地说，在确定系统信任时没有将加密系统之外的元数据考虑在内。 为了验证已在无信任系统中撤销的验证方法的证明签名，DID 方法需要支持 versionId 或 versionTime 中的一个或两个，以及 updated 和 nextUpdate、DID 文档元数据属性。 当且仅当满足以下所有条件时，验证者才能验证已撤销密钥的签名或证明：

- 证明或签名包括在创建签名或证明时使用的 DID 文档的 versionId 或 versionTime。
- 验证者可以确定签名或证明的时间点； 例如，它锚定在区块链上。
- 对于已解析的 DID 文档元数据，更新的时间戳在进行签名或证明的时间点之前，nextUpdate 时间戳在之后。

在愿意接受构成加密输入的元数据以外的元数据的系统中，可以实现类似的信任——但始终基于相同的基础，即在签名事件发生时仔细判断 DID 文档的内容是否包含期望的内容。

## 9.9 DID 恢复

恢复是一种反应性安全措施，控制器失去了执行 DID 操作的能力，例如由于设备的丢失，能够重新获得执行 DID 操作的能力。

在考虑使用 DID 恢复时，可能需要考虑以下注意事项：

- 不经常但定期主动执行恢复有助于确保控制没有丢失。
- 永远不要将与恢复相关的加密材料用于任何其他目的，这被认为是一种最佳实践。
- 恢复通常与验证方法轮换和验证方法撤销一起执行。
- 当受信行事的控制器或服务不再具有执行第 8.2 节“方法操作”中所述的 DID 操作的独占能力时，建议进行恢复。
- DID 方法规范可能会选择启用对受信任方法定人数的支持以促进恢复。 第 5.1.2 节 “DID 控制器”中建议了一些这样做的工具。
- 并非所有 DID 方法规范都能识别使用其他 DID 方法注册的 DID 的控制，并且它们可能会将第三方控制限制为使用相同方法的 DID。
- DID 方法规范中的访问控制和恢复还可以包括时间锁定功能，通过维护用于恢复的第二个控制轨道来防止密钥泄露。
- 目前没有适用于所有 DID 方法的通用恢复机制。

## 9.10 人性化标识符的作用

DID 无需中心化注册机构即可实现全球唯一性。 这是以人类记忆力为代价的。 能够生成全局明确标识符的算法会生成没有人类意义的随机字符串。 这种权衡通常被称为 [Zooko 三角](https://en.wikipedia.org/wiki/Zooko's_triangle)。

在某些用例中，人们希望人性化的标识符从发现 DID开始。 例如，自然语言名称、域名或 DID 控制器的常规地址，例如移动电话号码、电子邮件地址、社交媒体用户名或博客 URL。 但是，将人类友好的标识符映射到 DID ，并以可验证和信任的方式进行映射的问题超出了本规范的范围。

此问题的解决方案在引用此规范的单独规范中定义，例如[[DNS-DID\]](https://www.w3.org/TR/2021/PR-did-core-20210803/#bib-dns-did)。 强烈建议此类规范仔细考虑：

- 许多安全攻击基于欺骗用户关于目标实体真正的人性化标识符。
- 使用本质上相关的人类友好标识符的隐私后果，特别是如果它们是全球唯一的。

## 9.11 作为增强型 URN 的 DID

如果 DID 控制器需要，DID 或 DID URL 能够充当持久的、与位置无关的资源标识符。 这些类型的标识符被归类为统一资源名称 (URN)，并在 [[RFC8141\]](https://www.w3.org/TR/2021/PR-did-core-20210803/#bib-rfc8141)中定义。 DID 是 URN 的增强形式，它为数字资源提供加密安全、与位置无关的标识符，同时还提供支持检索的元数据。 由于 DID 文档和 DID 本身之间的间接性，DID 控制器可以调整资源的实际位置——甚至直接提供资源——而无需调整 DID。 这种类型的 DID 可以明确地验证检索到的资源实际上是标识的资源。

建议打算为此目的使用 DID 的 DID 控制器遵循[[RFC8141\]](https://www.w3.org/TR/2021/PR-did-core-20210803/#bib-rfc8141)中的安全注意事项。 尤其是：

- DID 控制器应选择支持控制器对持久性要求的 DID 方法。 去中心化特征量规 [[DID-RUBRIC]](https://www.w3.org/TR/2021/PR-did-core-20210803/#bib-did-rubric) 是一种工具，可帮助实施者决定最合适的 DID 方法。
- 预计 DID 控制器将发布其操作策略，以便请求方可以确定他们可以依赖由该 DID 控制器控制的 DID 的持久性的程度。 在没有此类政策的情况下，请求方不应对 DID 是否是同一 DID 主体的持久标识符做出任何假设。

## 9.12 不变性（Immutability）

许多网络安全滥用行为取决于利用现实与理性、善意行为者的假设之间的差距。 DID 文档的不变性可以提供一些安全优势。 单个 DID 方法应该考虑可以消除它们不需要的行为或语义的约束。 DID 方法*锁定*得越多，在提供相同功能集的同时，恶意行为者操纵它的可能性就越小。

例如，考虑对 DID 文档的单个编辑可以更改除文档的root id 属性之外的任何内容。 但是，服务在定义之后改变它的type真的是可取的吗？ 或者为一个key改变它的 value？ 或者当对象的某些基本属性发生变化时要求一个新的 id 会更好吗？ 恶意接管网站的目的往往是为了达到这样的结果，即网站保持其主机名称标识符，但背后某些内容被巧妙地改变。 如果规范要求站点的某些属性（例如与其 IP 地址关联的 [ASN](https://en.wikipedia.org/wiki/Autonomous_system_(Internet))）是不可变的，则异常检测将更容易，并且攻击的执行将更加困难和昂贵。

对于与全球真实源相联系的DID方法来说，直接、及时地查询DID文件的最新版本总是可能的。然而，在DID解析器和真理源之间，似乎最终可能会出现多层缓存。如果是这样，相信DID文档中的对象的属性有一个给定的状态，而它们实际上是有细微差别的，这可能会引起漏洞。如果一些查询是完整的DID文档，而另一些查询是假设较大上下文的部分数据，则尤其如此。

## 9.13 DID 文档中的加密数据

众所周知，由于密码学和计算能力的进步，加密算法会失效。 建议实施者假设放置在 DID 文档中的任何加密数据最终可能以明文形式提供给可以使用加密数据的相同受众。 如果 DID 文档是公开的，这一点尤其相关。

从长远来看，对 DID 文档的全部或部分进行加密并不是保护数据的合适方法。 同样，将加密数据放在 DID 文档中也不是保护个人数据的合适方法。

鉴于上述警告，如果 DID 文档中包含加密数据，建议实施者不要关联任何可用于推断加密数据与关联方之间关系的相关信息。 相关信息的示例包括接收方的公钥、已知受接收方控制的数字资产的标识符或接收方的人类可读描述。

## 9.14 等价性质

鉴于 equivalentId 和 canonicalId 属性是由 DID 方法本身生成的，适用于 DID 文档的 id 字段中所解析的 DID 的安全和准确性保证也适用于这些属性。alsoKnownAs属性不能保证是准确的等价声明，在不执行DID文档解析以外的验证步骤的情况下，不应依赖该属性。

equivalentId和canonicalId属性对由同一DID方法产生的单一DID的变体表达了等价断言，并且在请求方信任DID方法和符合要求的生产者和解析者的范围内可以被信任。

alsoKnownAs属性允许对不受同一DID方法管辖的URI进行等同性断言，如果不在管辖的DID方法之外执行验证步骤，就不能相信这些URI。请参阅第 5.1.3 节“[Also Known As](https://www.w3.org/TR/2021/PR-did-core-20210803/#also-known-as)”中的其他指南。

与DID文件中任何其他与安全有关的属性一样，依赖DID文件中任何等价声明的各方应防止这些属性的值在执行适当的验证后被攻击者取代。在进行验证后，对存储在内存或磁盘中的DID文件的任何写入访问都是一种攻击向量，可能会规避验证，除非DID文件被重新验证。

## 9.15 内容完整性保护

包含指向外部机器可读内容（如图像、网页或模式）的链接的 DID 文档很容易受到篡改。 强烈建议使用哈希链接[[HASHLINK\]](https://www.w3.org/TR/2021/PR-did-core-20210803/#bib-hashlink)等解决方案对外部链接进行完整性保护。 如果外部链接不能受到完整性保护并且 DID 文档的完整性依赖于外部链接，则应避免外部链接。

DID 文档本身的完整性可能受到影响的外部链接的一个示例是 JSON-LD 上下文[[JSON-LD11\]](https://www.w3.org/TR/2021/PR-did-core-20210803/#bib-json-ld11)。 为了防止泄露，建议 DID 文档使用者缓存 JSON-LD 上下文的本地静态副本和/或根据已知与外部 JSON-LD 上下文的安全版本相关联的加密哈希，验证外部上下文的完整性。

## 9.16 持久性

DID 被设计为具有持久性，因此控制器无需依赖单个受信任的第三方或管理员来维护其标识符。 在理想情况下，管理员不能从控制器手中夺走控制权，管理员也不能阻止其标识符用于任何特定目的，例如身份验证、授权和证明。 未经控制者同意，任何第三方均不得代表控制者删除实体标识符或使其无法使用。

然而，需要注意的是，在所有能够进行加密控制证明的DID方法中，证明控制的方法总是可以通过转移秘密的加密材料转移到另一方。因此，至关重要的是，依赖标识符随时间持续存在的系统应定期检查，以确保标识符实际上仍在预定方的控制之下。

不幸的是，仅从密码学上就不可能确定与某一特定验证方法相关的秘密密码材料是否已被破坏。很可能预期的控制者仍然可以访问秘密的加密材料——因此可以执行控制证明作为验证过程的一部分——而与此同时，不良行为者也可以访问这些相同的密钥，或其副本。

因此，加密控制证明预计只能作为评估高风险场景所需的身份保证水平的一个因素来使用。基于DID的认证提供了比用户名和密码大得多的保证，因为它能够确定对加密秘密的控制，而无需在系统之间传输该秘密。然而，它并不是无懈可击的。涉及敏感的、高价值的或生命攸关的操作的场景，预计将酌情使用额外的因素。

除了不同的控制者使用时可能产生的歧义外，一般来说，不可能保证在任何特定的时间点上，一个特定的DID被用于指代同一主体。从技术上讲，控制者有可能为不同的对象重复使用一个DID，更微妙的是，对象的精确定义会随着时间的推移而改变，或者被误解。

例如，考虑一个用于独资企业的DID，接收用于金融交易的各种凭证。对控制器来说，该标识符指的是企业。随着企业的发展，它最终被注册为一家有限责任公司。控制者继续使用同一个DID，因为对他们来说，DID指的是企业。然而，对于国家、税务机关和地方政府来说，DID不再是指同一个实体。对信贷提供者或供应商来说，意义上的微妙变化是否重要，必然由他们自己决定。在许多情况下，只要账单得到支付，并且可以执行收款，这种转变并不重要。

由于这些潜在的模糊性，DID将被视为有效的上下文而不是绝对的。它们的持续存在并不意味着它们指的是完全相同的主体，也不意味着它们是在同一个控制者的控制之下。相反，我们需要了解创建DID的背景，它是如何被使用的，并考虑其意义的可能转变，并采取程序和政策来解决潜在和不可避免的语义漂移。

## 9.17 保证级别（Level of Assurance (LOA)）

出于合规性原因，通常需要有关身份验证事件的安全上下文的其他信息，尤其是在金融和公共部门等受监管领域。 此信息通常称为保证级别 (LOA)。 示例包括对秘密加密材料的保护、身份证明过程和身份验证器的形式因素。

[支付服务 (PSD 2)](https://ec.europa.eu/info/law/payment-services-psd-2-directive-eu-2015-2366_en)和 [eIDAS](https://eur-lex.europa.eu/legal-content/EN/TXT/?uri=uriserv:OJ.L_.2014.257.01.0073.01.ENG) 将此类要求引入安全环境。 保证级别框架由 [eIDAS](https://eur-lex.europa.eu/legal-content/EN/TXT/?uri=uriserv:OJ.L_.2014.257.01.0073.01.ENG)、[NIST 800-63-3](https://pages.nist.gov/800-63-3/sp800-63-3.html) 和 [ISO/IEC 29115:2013](https://www.iso.org/standard/45138.html) 等法规和标准进行分类和定义，包括它们对安全环境的要求，并就如何实现这些要求提出建议。 这可能包括强大的用户身份验证，其中 [FIDO2](https://fidoalliance.org/fido2/)/[WebAuthn](https://www.w3.org/TR/webauthn-2/) 可以满足要求。

一些受监管的场景要求实施特定的保证水平。由于验证关系（如assertionMethod和authentication）可能会在其中一些情况下使用，因此可能需要表达有关应用安全背景的信息并提供给验证者。是否以及如何在DID文档数据模型中对这些信息进行编码超出了本规范的范围。有兴趣的读者可能会注意到：1）该信息可以使用可验证凭证[[VC-DATA-MODEL\]](https://www.w3.org/TR/2021/PR-did-core-20210803/#bib-vc-data-model)来传输，以及2）DID文档数据模型可以被扩展以纳入该信息，如第4.1节""可扩展性""中所述，并且第10节""隐私考虑""适用于这种扩展。